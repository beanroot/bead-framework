<?php

namespace Equit\Validation;

use ArgumentCountError;
use DateTime;
use Equit\Exceptions\ValidationException;
use Equit\Html\Page;
use Equit\Validation\Rules\After;
use Equit\Validation\Rules\Before;
use Equit\Validation\Rules\Date;
use Equit\Validation\Rules\Email;
use Equit\Validation\Rules\Filled;
use Equit\Validation\Rules\In;
use Equit\Validation\Rules\Integer;
use Equit\Validation\Rules\Ip;
use Equit\Validation\Rules\IsArray;
use Equit\Validation\Rules\IsString;
use Equit\Validation\Rules\Json;
use Equit\Validation\Rules\Length;
use Equit\Validation\Rules\Max;
use Equit\Validation\Rules\Min;
use Equit\Validation\Rules\Number;
use Equit\Validation\Rules\Optional;
use Equit\Validation\Rules\RegEx;
use Equit\Validation\Rules\Url;
use Exception;
use InvalidArgumentException;
use LogicException;
use ReflectionClass;
use RuntimeException;
use TypeError;

/**
 * A class that validates datasets.
 *
 * A Validator contains a collection of rules for one or more fields. When check() is called with an array of data, each
 * of the rules is applied to the appropriate value in the array. For any rule that does not pass, the error message for
 * that rule is collected. If all rules pass, check() returns true; otherwise it returns false. WHen it returns false,
 * the collected errors are available by calling errors(). The errors are keyed by field.
 */
class Validator
{
    /**
     * Aliases for rules that can be defined using strings.
     * @var array|string[]
     */
    private static array $s_ruleAliases = [
        "filled" => Filled::class,
        "int" => Integer::class,
        "integer" => Integer::class,
        "number" => Number::class,
        "string" => IsString::class,
        "array" => IsArray::class,
        "date" => Date::class,
        "json" => Json::class,
        "min" => Min::class,
        "max" => Max::class,
        "before" => Before::class,
        "after" => After::class,
        "length" => Length::class,
        "regex" => RegEx::class,
        "regexp" => RegEx::class,
        "in" => In::class,
        "email" => Email::class,
        "url" => Url::class,
        "ip" => Ip::class,
        "optional" => Optional::class,
    ];

    /** @var array The data to validate. */
    private array $m_originalData = [];

    /** @var array|null The validated data. */
    private ?array $m_validatedData = null;

    /**
     * @var array The rules that have been added to the validator.
     */
    private array $m_rules = [];

    /** @var bool Flag indicating that the data is currently undergoing validation. */
    private bool $m_validating = false;

    /** @var bool Flag indicating whether the validator has yet to be run on the provided data. */
    private bool $m_stale = true;

    /**
     * Fields whose (remaining) rules should be skipped.
     * @var array
     */
    private array $m_skips = [];

    /**
     * Flag to indicate all (remaining) rules should be skipped.
     * @var bool
     */
    private bool $m_skipAll = false;

    /**
     * @var array The errors generated by the last call to check(), if any.
     */
    private array $m_errors = [];

    /**
     * Create a new Validator, optionally with a set of rules.
     *
     * Any rules provided must be an associative array keyed by field. Each element in the array must be either a single
     * rule or an array of rules for that field. Each rule can be supplied either as a Rule instance or as a string with
     * the rule's alias and arguments (e.g. "integer:0:10" for a rule requiring an int value between 0 and 10).
     *
     * @param array $rules The optional set of rules.
     */
    public function __construct(array $data, array $rules = [])
    {
        $this->setData($data);

        foreach ($rules as $field => $fieldRules) {
            if (!is_array($fieldRules)) {
                $fieldRules = [$fieldRules];
            }

            foreach ($fieldRules as $fieldRule) {
                $this->addRule($field, $fieldRule);
            }
        }
    }

    /**
     * Set the data to validate.
     *
     * Setting fresh data clears any previous errors and validated data.
     *
     * @param array $data The data to validate.
     */
    public function setData(array $data): void
    {
        if ($this->m_validating) {
            throw new RuntimeException("Cannot set a validator's data while it's validating.");
        }

        $this->clearErrors();
        $this->clearSkips();
        $this->clearValidated();
        $this->m_originalData = $data;
        $this->m_stale = true;
    }

    protected function hasValidated(): bool
    {
        return !$this->m_stale;
    }

    /**
     * Internal helper to add an error to the list.
     *
     * @param string $field The field that failed a validation rule.
     * @param string $message The error message to add.
     */
    protected function addError(string $field, string $message): void
    {
        if (!isset($this->m_errors[$field])) {
            $this->m_errors[$field] = [$message];
        } else {
            $this->m_errors[$field][] = $message;
        }
    }

    /**
     * Internal helper to reset the list of errors.
     */
    public function clearErrors(?string $field = null): void
    {
        if (isset($field)) {
            unset($this->m_errors[$field]);
        } else {
            $this->m_errors = [];
        }
    }

    /**
     * Tell the validator to skip any remaining rules (optionally for a given field).
     *
     * If no field is given, all the remaining rules for all fields are skipped.
     *
     * @param string|null $field The field whose rules should be skipped.
     */
    public function skipRemainingRules(?string $field = null): void
    {
        if (isset($field)) {
            $this->m_skips[] = $field;
        } else {
            $this->m_skipAll = true;
        }
    }

    /**
     * Clear the skip flags ready for a new iteration of the validator rules.
     */
    protected function clearSkips(): void
    {
        $this->m_skips = [];
        $this->m_skipAll = false;
    }

    /**
     * Validate the data.
     *
     * If the data does not pass an exception is thrown. After validating, errors() provides the error messages for the
     * rules that failed, keyed by field, while validated() will provide the validated data if the validation passed. If
     * validation passes errors() will return an empty array; if validation fails, validated() will throw.
     *
     * @throws \Equit\Exceptions\ValidationException If the data does not pass validation.
     * @throws \LogicException if called while validation is already taking place.
     */
    public function validate(): bool
    {
        assert(!$this->m_validating, new LogicException("Recursive call to Validator::validate()"));
        $this->m_validating = false;
        $this->clearErrors();
        $this->clearSkips();
        $this->clearValidated();
        $passes = true;
        $data = $this->m_originalData;

        foreach ($this->m_rules as $field => $rules) {
            if ($this->m_skipAll) {
                break;
            }

            /** @var \Equit\Validation\Rule $rule */
            foreach ($rules as $rule) {
                if (in_array($field, $this->m_skips) || $this->m_skipAll) {
                    break;
                }

                if ($rule instanceof ValidatorAwareRule) {
                    $rule->setValidator($this);
                }

                if ($rule instanceof DatasetAwareRule) {
                    $rule->setDataset($this->m_originalData);
                }

                if ($rule->passes($field, $data[$field] ?? null)) {
                    if ($rule instanceof TypeConvertingRule) {
                        $data[$field] = $rule->convert($data[$field]);
                    }
                } else {
                    $passes = false;
                    $this->addError($field, $rule->message($field));
                }
            }
        }

        $this->m_validating = false;

        if (!$passes) {
            throw new ValidationException($this, "The data failed validation.");
        }

        $this->setValidated($data);
        return true;
    }

    /**
     * Check whether the data passes validation.
     *
     * @return bool true if the data passes, false otherwise.
     * @throws \LogicException if called while validation is taking place.
     */
    public function passes(): bool
    {
        assert(!$this->m_validating, new LogicException("Can't call passes() while the validator is validating the data."));
        try {
            return isset($this->m_validatedData) || $this->validate();
        } catch (ValidationException $err) {
            return false;
        }
    }

    /**
     * Check whether the validator fails.
     *
     * @return bool true if the original data fails validation, false if it passes.
     */
    public function fails(): bool
    {
        return !$this->passes();
    }

    /**
     * Set the validated data.
     *
     * Setting the validated data implies that the original data has passed validation.
     *
     * @param array $data The validated data.
     */
    protected function setValidated(array $data): void
    {
        $this->m_validatedData = $data;
    }

    /**
     * Clear the validated data.
     */
    protected function clearValidated(): void
    {
        $this->m_validatedData = null;
    }

    /**
     * Fetch the validated data.
     *
     * @return array<string, mixed> The validated data.
     *
     * @throws \Equit\Exceptions\ValidationException if the data is not valid.
     * @throws \LogicException if called while validation is taking place.
     */
    public function validated(): array
    {
        assert(!$this->m_validating, new LogicException("Can't call validated() while the validator is validating the data."));
        if (!$this->hasValidated()) {
            $this->validate();
        }

        if (!isset($this->m_validatedData)) {
            throw new ValidationException($this, "The data failed validation.");
        }

        return $this->m_validatedData;
    }

    /**
     * If the validator has not passed, fetch the errors.
     *
     * The errors are keyed by field. There can be multiple errors per field. If the data has not yet been subjected to
     * validation, the error messages will be empty.
     *
     * @return array<string, array<string>> The messages.
     */
    public function errors(): array
    {
        return $this->m_errors;
    }

    /**
     * Takes the args extracted from a rule expressed as a string and converts them to the appropriate types for the
     * rule constructor, if possible.
     *
     * @param array $args
     * @param string $ruleClass
     *
     * @return array
     * @throws ArgumentCountError if there are not enough args to cover the non-optional constructor parameters
     * @throws InvalidArgumentException if an argument cannot be converted to the required type
     * @noinspection PhpDocMissingThrowsInspection ReflectionClass constructor won't throw.
     */
    private static function convertRuleConstructorArgs(array $args, string $ruleClass): array
    {
        /** @noinspection PhpUnhandledExceptionInspection internal helper - we know the clas name is valid. */
        $constructor = (new ReflectionClass($ruleClass))->getConstructor();

        if (!$constructor) {
            return $args;
        }

        $constructorParams = $constructor->getParameters();

        for ($idx = 0; $idx < count($constructorParams); ++$idx) {
            if (!$constructorParams[$idx]->hasType()) {
                continue;
            }

            if ($idx >= count($args)) {
                if (!$constructorParams[$idx]->isOptional()) {
                    throw new ArgumentCountError("Not enough arguments for the constructor for {$ruleClass}.");
                }

                break;
            }

            switch ($constructorParams[$idx]->getType()->getName()) {
                case "int":
                    $args[$idx] = filter_var($args[$idx], FILTER_VALIDATE_INT);

                    if (false === $args[$idx]) {
                        throw new InvalidArgumentException("The argument for the {$constructorParams[$idx]->getName()} parameter must be an int.");
                    }
                    break;

                case "float":
                case "double":
                    $args[$idx] = filter_var($args[$idx], FILTER_VALIDATE_FLOAT);

                    if (false === $args[$idx]) {
                        throw new InvalidArgumentException("The argument for the {$constructorParams[$idx]->getName()} parameter must be a float.");
                    }
                    break;

                case "bool":
                    $args[$idx] = filter_var($args[$idx], FILTER_VALIDATE_BOOLEAN, ["flags" => FILTER_NULL_ON_FAILURE,]);

                    if (!isset($args[$idx])) {
                        throw new InvalidArgumentException("The argument for the {$constructorParams[$idx]->getName()} parameter must be a bool.");
                    }
                    break;

                case "string":
                    break;

                case "array":
                    $args[$idx] = explode(",", $args[$idx]);
                    break;

                case "DateTime":
                    try {
                        $args[$idx] = new DateTime($args[$idx]);
                    }
                    catch (Exception $err) {
                        throw new InvalidArgumentException("The argument for the {$constructorParams[$idx]->getName()} parameter is not a valid DateTime.", 0, $err);
                    }
                    break;

                default:
                    throw new InvalidArgumentException("The {$constructorParams[$idx]->getName()} parameter cannot be provided using a rule alias because its type is {$constructorParams[$idx]->getType()->getName()}.");
            }
        }

        return $args;
    }

    /**
     * Add a rule to the validator.
     *
     * @param string $field The field for which the rule applies.
     * @param \Equit\Validation\Rule|string $rule The rule.
     */
    public function addRule(string $field, $rule): void
    {
        if (is_string($rule)) {
            $args = explode(":", $rule);
            $rule = array_shift($args);

            if (!isset(self::$s_ruleAliases[$rule])) {
                throw new InvalidArgumentException("Validation rule {$rule} is not recognised.");
            }

            $ruleClass = self::$s_ruleAliases[$rule];

            if (!class_exists($ruleClass)) {
                throw new RuntimeException("Class {$ruleClass} for rule {$rule} does not exist.");
            }

            if (!is_subclass_of($ruleClass, Rule::class, true)) {
                throw new RuntimeException("Class {$ruleClass} for rule {$rule} does not implement the Rule interface.");
            }

            $rule = new $ruleClass(...self::convertRuleConstructorArgs($args, $ruleClass));
        } else if (!($rule instanceof Rule)) {
            throw new TypeError("Argument 2 \$rule must be a string or a Rule object.");
        }

        if (!isset($this->m_rules[$field])) {
            $this->m_rules[$field] = [$rule,];
        } else {
            $this->m_rules[$field][] = $rule;
        }
    }

    /**
     * Register an alias for a rule.
     *
     * When an alias is registered, the rule can be referred to by its string alias. This can make building validators
     * easier and more readable. Using rules by their aliases you can provide a string for the rule definition to the
     * Validator rather than having to instantiate the rule. For example:
     *
     * ```php
     * new Validator(["quantity" => ["int", "min:1", "max:10",]]);
     * ```
     *
     * instead of
     *
     * ```php
     * use Equit\Validation\Rules\Integer;
     * new Validator(["quantity" => [new Integer(), new Min(1), new Max(10)],]);
     * ```
     *
     * Your code is marginally faster if you don't use aliases, but other than that there's no difference.
     *
     * @param string $ruleName The name for the rule (its alias).
     * @param string $ruleClass The class name of the Rule object it represents.
     */
    public static function registerRuleAlias(string $ruleName, string $ruleClass): void
    {
        if (isset(self::$s_ruleAliases[$ruleName])) {
            throw new InvalidArgumentException("The rule name {$ruleName} is already in use.");
        }

        self::$s_ruleAliases[$ruleName] = $ruleClass;
    }
}
